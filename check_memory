#!/bin/bash
# shellcheck disable=SC2312

# Plugin Name: check_memory
# Description: Checks system memory
# Date: 01/01/2025

# Flags
ALLOW_ZERO_INPUT=true
PREFIX="MEM"

# Global Variables
WARNING_LEVEL=80
CRITICAL_LEVEL=90

# Main
function main()
{
    local mem_total mem_free mem_buffers mem_cached mem_used 
    local mem_used_pct mem_warn_pct mem_crit_pct
    local f_mem_total f_mem_free f_mem_used
    local message data

    # Error if can't read mem info
    if ! grep -q "MemTotal" /proc/meminfo; then
        handle_unknown "Unable to read /proc/meminfo"
    fi

    # Get memory values from /proc/meminfo
    mem_total=$(grep MemTotal /proc/meminfo | awk '{print $2}')
    mem_free=$(grep MemFree /proc/meminfo | awk '{print $2}')
    mem_buffers=$(grep Buffers /proc/meminfo | awk '{print $2}')
    mem_cached=$(grep ^Cached /proc/meminfo | awk '{print $2}')
    mem_used=$((mem_total - mem_free - mem_buffers - mem_cached))

    # Calculate usage percentage
    mem_used_pct=$(awk -v used="$mem_used" -v total="$mem_total" 'BEGIN { printf "%.1f\n", 100 * used / total }')
    mem_warn_pct=$(awk "BEGIN {print int(($WARNING_LEVEL / 100) * $mem_total )}")
    mem_crit_pct=$(awk "BEGIN {print int(($CRITICAL_LEVEL / 100) * $mem_total )}")

    # Generate output
    f_mem_total=$(format_bytes "$mem_total") 
    f_mem_free=$(format_bytes "$mem_free")
    f_mem_used=$(format_bytes "$mem_used")
    message="${mem_used_pct}% memory used (${f_mem_used} used of ${f_mem_total}, ${f_mem_free} free)"
    data="mem_total=${mem_total};;;; mem_used=${mem_used};${mem_warn_pct};${mem_crit_pct};; mem_free=${mem_free};;;; mem_cached=${mem_cached};;;; mem_buffers=${mem_buffers};;;;"

    # Compare to threshold values
    if (( $(echo "${mem_used_pct} >= ${CRITICAL_LEVEL}" | bc -l) )); then
        handle_critical "${message}" "${data}"
    elif (( $(echo "${mem_used_pct} >= ${WARNING_LEVEL}" | bc -l) )); then
        handle_warning "${message}" "${data}"
    elif (( $(echo "${mem_used_pct} >= 0" | bc -l) )); then
        handle_ok "${message}" "${data}"
    else
        handle_unknown "Invalid memory value" "${data}"
    fi
}

# Format byte values base on magnitude 
function format_bytes() {
    local kb="$1"
    local unit="KB"
    local value="$kb"

    if (( kb >= 1024 * 1024 * 1024 )); then
        value=$(awk "BEGIN {printf \"%.2f\", $kb/1073741824}")
        unit="TB"
    elif (( kb >= 1024 * 1024 )); then
        value=$(awk "BEGIN {printf \"%.2f\", $kb/1048576}")
        unit="GB"
    elif (( kb >= 1024 )); then
        value=$(awk "BEGIN {printf \"%.2f\", $kb/1024}")
        unit="MB"
    fi

    echo "${value}${unit}"
}

# Usage (-h parameter)
function usage()
{
cat <<EOF
  Usage: $0 [ -h ] [ -c value ] [ -w value ]
    -h, --help      : Print this screen
    -c, --critical  : Critical percentage of memory used [Default: ${CRITICAL_LEVEL}]
    -w, --warning   : Warn percentage of memory used [Default: ${WARNING_LEVEL}]
EOF
    exit 0
}

# Process Arguments
function process_arguments()
{
    # Check if no arguments is allowed
    if [[ "${ALLOW_ZERO_INPUT}" = false ]] && [[ $# -eq 0 ]]; then
        handle_unknown "No parameters given"
    fi

    # Define short and long options
    SHORTOPTS=h,c:,w:
    LONGOPTS=help,critical:,warning:

    # Parse options using getopt
    OPTIONS=$(getopt --options=$SHORTOPTS --longoptions=$LONGOPTS --name "$0" -- "$@")
    if [[ $? -ne 0 ]]; then
        handle_unknown "Failed to parse arguments"
    fi

    # Reorder positional parameters
    eval set -- "${OPTIONS}"

    while true; do
        case "$1" in
            -h|--help)
                usage
                ;;
            -c|--critical)
                CRITICAL_LEVEL="$2"
                shift 2
                ;;
            -w|--warning)
                WARNING_LEVEL="$2"
                shift 2
                ;;
            --)
                shift
                break
                ;;
            *)
                handle_unknown "Unknown option: $1"
                ;;
        esac
    done

    # Validate warning and critical values
    if (( $(echo "${WARNING_LEVEL} >= ${CRITICAL_LEVEL}" | bc -l) )); then
        handle_unknown "Warning threshold must be lower than critical threshold"
    fi

    main
}

# Handle OK / Warning / Critical / Unknown
function handle_ok() {
    local message="${1:-}"
    local perfdata="${2:-}"
    echo "${PREFIX:+${PREFIX} }OK - ${message}${perfdata:+ | ${perfdata}}"
    exit 0
}

function handle_warning() {
    local message="${1:-}"
    local perfdata="${2:-}"
    echo "${PREFIX:+${PREFIX} }WARNING - ${message}${perfdata:+ | ${perfdata}}"
    exit 1
}

function handle_critical() {
    local message="${1:-}"
    local perfdata="${2:-}"
    echo "${PREFIX:+${PREFIX} }CRITICAL - ${message}${perfdata:+ | ${perfdata}}"
    exit 2
}

function handle_unknown() {
    local message="${1:-}"
    local perfdata="${2:-}"
    echo "${PREFIX:+${PREFIX} }UNKNOWN - ${message}${perfdata:+ | ${perfdata}}"
    exit 3
}

# Core
process_arguments "${@}"